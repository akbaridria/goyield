#pragma version 9

// This TEAL was generated by TEALScript v0.60.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication(string,string)void
//
// // constructor
abi_route_createApplication:
	// _symbol: string
	txna ApplicationArgs 2
	extract 2 0

	// _name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createApplication(string,string)void
	callsub createApplication
	int 1
	return

createApplication:
	proto 2 0

	// contracts/GoYieldNFT.algo.ts:44
	// this.name.value = _name
	byte 0x6e616d65 // "name"
	frame_dig -1 // _name: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts/GoYieldNFT.algo.ts:45
	// this.symbol.value = _symbol
	byte 0x73796d626f6c // "symbol"
	frame_dig -2 // _symbol: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put
	retsub

updateTransfer:
	proto 6 0

	// contracts/GoYieldNFT.algo.ts:50
	// index: uint64 = 0
	int 0
	frame_bury -4 // index: uint64

	// contracts/GoYieldNFT.algo.ts:51
	// i: uint64 = 0
	int 0
	frame_bury -5 // i: uint64

	// contracts/GoYieldNFT.algo.ts:52
	// length: uint64 = this.ownerBox(_from).value.length
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	len
	int 8
	/
	frame_bury -6 // length: uint64
	frame_dig -5 // i: uint64

for_0:
	frame_dig -5 // i: uint64
	frame_dig -6 // length: uint64
	<
	bz for_0_end

	// if0_condition
	// contracts/GoYieldNFT.algo.ts:55
	// this.ownerBox(_from).value[i] === _tokenId
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	store 0 // full array
	int 0 // initial offset
	frame_dig -5 // i: uint64
	int 8
	* // acc * typeLength
	+
	load 0 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig -3 // _tokenId: uint64
	==
	bz if0_end

	// if0_consequent
	// contracts/GoYieldNFT.algo.ts:56
	// index = i
	frame_dig -5 // i: uint64
	frame_bury -4 // index: uint64

if0_end:
	// contracts/GoYieldNFT.algo.ts:54
	// i = i + 1
	frame_dig -5 // i: uint64
	int 1
	+
	frame_bury -5 // i: uint64
	b for_0

for_0_end:
	// contracts/GoYieldNFT.algo.ts:59
	// this.ownerBox(_from).value.splice(index, 1)
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	int 1
	frame_dig -4 // index: uint64
	int 8
	*
	store 12 // splice start
	int 16
	store 13 // splice byte length
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	int 0
	load 12 // splice start
	substring3
	frame_dig -1 // _from: address
	box_get
	assert
	extract 2 0
	dup
	len
	load 12 // splice start
	load 13 // splice byte length
	+
	int 8
	-
	swap
	substring3
	concat
	frame_dig -1 // _from: address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// if1_condition
	// contracts/GoYieldNFT.algo.ts:60
	// this.ownerBox(_to).exists
	frame_dig -2 // _to: address
	box_len
	swap
	pop
	bz if1_else

	// if1_consequent
	// contracts/GoYieldNFT.algo.ts:61
	// this.ownerBox(_to).value.push(_tokenId)
	frame_dig -2 // _to: address
	box_get
	assert
	extract 2 0
	frame_dig -3 // _tokenId: uint64
	itob
	concat
	frame_dig -2 // _to: address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b if1_end

if1_else:
	// contracts/GoYieldNFT.algo.ts:63
	// this.ownerBox(_to).value = [_tokenId]
	frame_dig -2 // _to: address
	dup
	box_del
	pop
	frame_dig -3 // _tokenId: uint64
	itob
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

if1_end:
	retsub

transferTo:
	proto 2 0

	// contracts/GoYieldNFT.algo.ts:68
	// assert(this.tokenBox(_tokenId).exists)
	frame_dig -2 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:69
	// this.tokenBox(_tokenId).value.owner = _to
	frame_dig -2 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 0
	frame_dig -1 // _to: address
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

	// contracts/GoYieldNFT.algo.ts:70
	// this.tokenBox(_tokenId).value.control = globals.zeroAddress
	frame_dig -2 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 36
	global ZeroAddress
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// arc72_ownerOf(uint64)address
//
// // read methods
abi_route_arc72_ownerOf:
	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc72_ownerOf(uint64)address
	callsub arc72_ownerOf
	int 1
	return

arc72_ownerOf:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:75
	// assert(this.tokenBox(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:76
	// return this.tokenBox(_tokenId).value.owner;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_tokenURI(uint64)string
abi_route_arc72_tokenURI:
	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc72_tokenURI(uint64)string
	callsub arc72_tokenURI
	int 1
	return

arc72_tokenURI:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:80
	// return this.tokenBox(_tokenId).value.tokenUri;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	int 32
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_getImage(uint64)string
abi_route_arc72_getImage:
	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc72_getImage(uint64)string
	callsub arc72_getImage
	int 1
	return

arc72_getImage:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:84
	// return this.tokenBox(_tokenId).value.image;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	int 34
	load 0 // full array
	load 0 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 0 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	dup
	len
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_totalSupply()uint64
abi_route_arc72_totalSupply:
	// execute arc72_totalSupply()uint64
	callsub arc72_totalSupply
	int 1
	return

arc72_totalSupply:
	proto 0 0

	// contracts/GoYieldNFT.algo.ts:88
	// return this.counter.value;
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_getApproved(uint64)address
abi_route_arc72_getApproved:
	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc72_getApproved(uint64)address
	callsub arc72_getApproved
	int 1
	return

arc72_getApproved:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:92
	// return this.tokenBox(_tokenId).value.control;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 36 32
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_isApprovedForAll(address,address)bool
abi_route_arc72_isApprovedForAll:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// _operator: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_isApprovedForAll(address,address)bool
	callsub arc72_isApprovedForAll
	int 1
	return

arc72_isApprovedForAll:
	proto 3 0

	// contracts/GoYieldNFT.algo.ts:96
	// control: StaticArray<Address, 2> = [_owner, _operator]
	frame_dig -1 // _owner: address
	frame_dig -2 // _operator: address
	concat
	frame_bury -3 // control: address[2]

	// if2_condition
	// contracts/GoYieldNFT.algo.ts:97
	// this.approveAllBox(control).exists
	frame_dig -3 // control: address[2]
	box_len
	swap
	pop
	bz if2_end

	// if2_consequent
	// contracts/GoYieldNFT.algo.ts:97
	// return true;
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

if2_end:
	// contracts/GoYieldNFT.algo.ts:98
	// return false;
	int 0
	byte 0x00
	int 0
	uncover 2
	setbit
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_balanceOf(address)uint64
abi_route_arc72_balanceOf:
	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_balanceOf(address)uint64
	callsub arc72_balanceOf
	int 1
	return

arc72_balanceOf:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:102
	// assert(this.ownerBox(_owner).exists)
	frame_dig -1 // _owner: address
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:103
	// return this.ownerBox(_owner).value.length;
	frame_dig -1 // _owner: address
	box_get
	assert
	extract 2 0
	frame_dig -1 // _owner: address
	box_get
	assert
	extract 2 0
	len
	int 8
	/
	itob
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_custom_getAllTokenIdsByAddr(address)uint64[]
abi_route_arc72_custom_getAllTokenIdsByAddr:
	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_custom_getAllTokenIdsByAddr(address)uint64[]
	callsub arc72_custom_getAllTokenIdsByAddr
	int 1
	return

arc72_custom_getAllTokenIdsByAddr:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:107
	// assert(this.ownerBox(_owner).exists)
	frame_dig -1 // _owner: address
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:108
	// return this.ownerBox(_owner).value;
	frame_dig -1 // _owner: address
	box_get
	assert
	extract 2 0
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// arc72_custom_getTokenDetail(uint64)(address,string,string,address)
abi_route_arc72_custom_getTokenDetail:
	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute arc72_custom_getTokenDetail(uint64)(address,string,string,address)
	callsub arc72_custom_getTokenDetail
	int 1
	return

arc72_custom_getTokenDetail:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:112
	// assert(this.tokenBox(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:113
	// return this.tokenBox(_tokenId).value;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get
	assert
	byte 0x151f7c75
	swap
	concat
	log
	retsub

// udpdateTemplate(string)void
//
// // write methods
abi_route_udpdateTemplate:
	// _template: string
	txna ApplicationArgs 1
	extract 2 0

	// execute udpdateTemplate(string)void
	callsub udpdateTemplate
	int 1
	return

udpdateTemplate:
	proto 1 0

	// contracts/GoYieldNFT.algo.ts:119
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/GoYieldNFT.algo.ts:120
	// this.svgTemplate(0).value = _template
	byte 0x74656d706c6174650000000000000000
	byte 0x74656d706c6174650000000000000000
	box_del
	pop
	frame_dig -1 // _template: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	box_put
	retsub

// arc72_approve(uint64,address)void
abi_route_arc72_approve:
	// _tokenId: uint64
	txna ApplicationArgs 2
	btoi

	// _approved: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_approve(uint64,address)void
	callsub arc72_approve
	int 1
	return

arc72_approve:
	proto 2 0

	// contracts/GoYieldNFT.algo.ts:124
	// assert(this.tokenBox(_tokenId).exists)
	frame_dig -2 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/GoYieldNFT.algo.ts:125
	// assert(this.txn.sender === this.tokenBox(_tokenId).value.owner)
	txn Sender
	frame_dig -2 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	==
	assert

	// contracts/GoYieldNFT.algo.ts:127
	// this.tokenBox(_tokenId).value.control = _approved
	frame_dig -2 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	int 36
	frame_dig -1 // _approved: address
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// arc72_setApprovalForAll(bool,address)void
abi_route_arc72_setApprovalForAll:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// _approved: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==
	assert
	int 0
	getbit

	// _operator: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_setApprovalForAll(bool,address)void
	callsub arc72_setApprovalForAll
	int 1
	return

arc72_setApprovalForAll:
	proto 3 0

	// contracts/GoYieldNFT.algo.ts:131
	// control: StaticArray<Address, 2> = [this.txn.sender, _operator]
	txn Sender
	frame_dig -1 // _operator: address
	concat
	frame_bury -3 // control: address[2]

	// contracts/GoYieldNFT.algo.ts:132
	// assert(this.approveAllBox(control).exists)
	frame_dig -3 // control: address[2]
	box_len
	swap
	pop
	assert

	// if3_condition
	// contracts/GoYieldNFT.algo.ts:134
	// _approved
	frame_dig -2 // _approved: bool
	bz if3_else

	// if3_consequent
	// contracts/GoYieldNFT.algo.ts:134
	// this.approveAllBox(control).value = ''
	frame_dig -3 // control: address[2]
	dup
	box_del
	pop
	byte 0x // ""
	box_put
	b if3_end

if3_else:
	// contracts/GoYieldNFT.algo.ts:135
	// this.approveAllBox(control).delete()
	frame_dig -3 // control: address[2]
	box_del

if3_end:
	retsub

// arc72_transferFrom(uint64,address,address)void
abi_route_arc72_transferFrom:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// _tokenId: uint64
	txna ApplicationArgs 3
	btoi

	// _to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==
	assert

	// _from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==
	assert

	// execute arc72_transferFrom(uint64,address,address)void
	callsub arc72_transferFrom
	int 1
	return

arc72_transferFrom:
	proto 5 0

	// contracts/GoYieldNFT.algo.ts:139
	// ownerNft = this.tokenBox(_tokenId).value.owner
	frame_dig -3 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	frame_bury -4 // ownerNft: address

	// contracts/GoYieldNFT.algo.ts:140
	// control: StaticArray<Address, 2> = [ownerNft, this.txn.sender]
	frame_dig -4 // ownerNft: address
	txn Sender
	concat
	frame_bury -5 // control: address[2]

	// if4_condition
	// contracts/GoYieldNFT.algo.ts:142
	// this.txn.sender === this.tokenBox(_tokenId).value.owner || this.tokenBox(_tokenId).value.control === this.txn.sender || this.approveAllBox(control).exists
	txn Sender
	frame_dig -3 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 0 32
	==
	dup
	bnz skip_or0
	frame_dig -3 // _tokenId: uint64
	itob
	box_get
	assert
	store 0 // full array
	load 0 // full array
	extract 36 32
	txn Sender
	==
	||

skip_or0:
	dup
	bnz skip_or1
	frame_dig -5 // control: address[2]
	box_len
	swap
	pop
	||

skip_or1:
	bz if4_else

	// if4_consequent
	// contracts/GoYieldNFT.algo.ts:143
	// this.transferTo(_to, _tokenId)
	frame_dig -3 // _tokenId: uint64
	frame_dig -2 // _to: address
	callsub transferTo

	// contracts/GoYieldNFT.algo.ts:144
	// this.updateTransfer(_from, _to, _tokenId)
	byte 0x; dupn 2 // push empty bytes to fill the stack frame for this subroutine's local variables
	frame_dig -3 // _tokenId: uint64
	frame_dig -2 // _to: address
	frame_dig -1 // _from: address
	callsub updateTransfer
	b if4_end

if4_else:
	err // 'not authorize'

if4_end:
	retsub

// mint(address,string,string,string,string,string)void
abi_route_mint:
	byte 0x; dup // push empty bytes to fill the stack frame for this subroutine's local variables

	// to: address
	txna ApplicationArgs 6
	dup
	len
	int 32
	==
	assert

	// tokenUri: string
	txna ApplicationArgs 5
	extract 2 0

	// translateY: string
	txna ApplicationArgs 4
	extract 2 0

	// translateX: string
	txna ApplicationArgs 3
	extract 2 0

	// objectColor: string
	txna ApplicationArgs 2
	extract 2 0

	// backgroundColor: string
	txna ApplicationArgs 1
	extract 2 0

	// execute mint(address,string,string,string,string,string)void
	callsub mint
	int 1
	return

mint:
	proto 8 0

	// contracts/GoYieldNFT.algo.ts:149
	// assert(this.counter.value < 1000)
	byte 0x636f756e746572 // "counter"
	app_global_get
	int 1000
	<
	assert

	// contracts/GoYieldNFT.algo.ts:150
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/GoYieldNFT.algo.ts:152
	// verifyTxn(this.txnGroup[0], { typeEnum: TransactionType.Payment })
	// verify typeEnum
	int 0
	gtxns TypeEnum
	int pay
	==
	assert

	// contracts/GoYieldNFT.algo.ts:153
	// verifyTxn(this.txnGroup[0], { amount: { greaterThanEqualTo: 10_000_000 } })
	// verify amount
	int 0
	gtxns Amount
	int 10_000_000
	>=
	assert

	// contracts/GoYieldNFT.algo.ts:154
	// verifyTxn(this.txnGroup[0], { receiver: this.app.creator })
	// verify receiver
	int 0
	gtxns Receiver
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/GoYieldNFT.algo.ts:156
	// verifyTxn(this.txnGroup[1], { typeEnum: TransactionType.Payment })
	// verify typeEnum
	int 1
	gtxns TypeEnum
	int pay
	==
	assert

	// contracts/GoYieldNFT.algo.ts:157
	// verifyTxn(this.txnGroup[1], { receiver: this.app.address })
	// verify receiver
	int 1
	gtxns Receiver
	global CurrentApplicationAddress
	==
	assert

	// contracts/GoYieldNFT.algo.ts:158
	// verifyTxn(this.txnGroup[1], { amount: { greaterThanEqualTo: 1_000_000 } })
	// verify amount
	int 1
	gtxns Amount
	int 1_000_000
	>=
	assert

	// contracts/GoYieldNFT.algo.ts:160
	// template: string = this.svgTemplate(0).value
	byte 0x74656d706c6174650000000000000000
	box_get
	assert
	extract 2 0
	frame_bury -7 // template: string

	// contracts/GoYieldNFT.algo.ts:162
	// token: Token = {
	//       owner: to,
	//       tokenUri: tokenUri,
	//       image: concat(concat(concat(concat(concat(substring3(template, 0, 205), backgroundColor), concat(substring3(template, 205, 238), translateX)), concat(' ', translateY)), concat(substring3(template, 239, 568), objectColor)), substring3(template, 568, 587)),
	//       control: globals.zeroAddress,
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0044 // initial head offset
	frame_dig -6 // to: address
	callsub process_static_tuple_element
	frame_dig -5 // tokenUri: bytes
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	frame_dig -7 // template: string
	int 0
	int 205
	substring3
	frame_dig -1 // backgroundColor: bytes
	concat
	frame_dig -7 // template: string
	int 205
	int 238
	substring3
	frame_dig -3 // translateX: bytes
	concat
	concat
	byte 0x20 // " "
	frame_dig -4 // translateY: bytes
	concat
	concat
	frame_dig -7 // template: string
	int 239
	int 568
	substring3
	frame_dig -2 // objectColor: bytes
	concat
	concat
	frame_dig -7 // template: string
	int 568
	int 587
	substring3
	concat
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub process_dynamic_tuple_element
	global ZeroAddress
	callsub process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury -8 // token: Token

	// contracts/GoYieldNFT.algo.ts:169
	// this.tokenBox(this.counter.value).value = token
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig -8 // token: Token
	box_put

	// if5_condition
	// contracts/GoYieldNFT.algo.ts:170
	// this.ownerBox(to).exists
	frame_dig -6 // to: address
	box_len
	swap
	pop
	bz if5_else

	// if5_consequent
	// contracts/GoYieldNFT.algo.ts:171
	// this.ownerBox(to).value.push(this.counter.value)
	frame_dig -6 // to: address
	box_get
	assert
	extract 2 0
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	concat
	frame_dig -6 // to: address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b if5_end

if5_else:
	// contracts/GoYieldNFT.algo.ts:173
	// this.ownerBox(to).value = [this.counter.value]
	frame_dig -6 // to: address
	dup
	box_del
	pop
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

if5_end:
	// contracts/GoYieldNFT.algo.ts:175
	// this.counter.value = this.counter.value + 1
	byte 0x636f756e746572 // "counter"
	byte 0x636f756e746572 // "counter"
	app_global_get
	int 1
	+
	app_global_put
	retsub

create_NoOp:
	method "createApplication(string,string)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "arc72_ownerOf(uint64)address"
	method "arc72_tokenURI(uint64)string"
	method "arc72_getImage(uint64)string"
	method "arc72_totalSupply()uint64"
	method "arc72_getApproved(uint64)address"
	method "arc72_isApprovedForAll(address,address)bool"
	method "arc72_balanceOf(address)uint64"
	method "arc72_custom_getAllTokenIdsByAddr(address)uint64[]"
	method "arc72_custom_getTokenDetail(uint64)(address,string,string,address)"
	method "udpdateTemplate(string)void"
	method "arc72_approve(address,uint64)void"
	method "arc72_setApprovalForAll(address,bool)void"
	method "arc72_transferFrom(address,address,uint64)void"
	method "mint(string,string,string,string,string,address)void"
	txna ApplicationArgs 0
	match abi_route_arc72_ownerOf abi_route_arc72_tokenURI abi_route_arc72_getImage abi_route_arc72_totalSupply abi_route_arc72_getApproved abi_route_arc72_isApprovedForAll abi_route_arc72_balanceOf abi_route_arc72_custom_getAllTokenIdsByAddr abi_route_arc72_custom_getTokenDetail abi_route_udpdateTemplate abi_route_arc72_approve abi_route_arc72_setApprovalForAll abi_route_arc72_transferFrom abi_route_mint
	err

process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub