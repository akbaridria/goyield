#pragma version 9

// This TEAL was generated by TEALScript v0.60.1
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implmented in the contract, its repsective branch will be "NOT_IMPLMENTED" which just contains "err"
txn ApplicationID
int 0
>
int 6
*
txn OnCompletion
+
switch create_NoOp NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED NOT_IMPLEMENTED call_NoOp

NOT_IMPLEMENTED:
	err

// createApplication(uint64,uint64)void
abi_route_createApplication:
	// vrfAppId: uint64
	txna ApplicationArgs 2
	btoi

	// nftAppId: uint64
	txna ApplicationArgs 1
	btoi

	// execute createApplication(uint64,uint64)void
	callsub createApplication
	int 1
	return

createApplication:
	proto 2 0

	// contracts/nftHub.algo.ts:17
	// this.claimed.value = [1001, 1001, 1001]
	byte 0x636c61696d6564 // "claimed"
	byte 0x00000000000003e900000000000003e900000000000003e9
	app_global_put

	// contracts/nftHub.algo.ts:18
	// this.nftAppId.value = nftAppId
	byte 0x6e66744170704964 // "nftAppId"
	frame_dig -1 // nftAppId: uint64
	app_global_put

	// contracts/nftHub.algo.ts:19
	// this.vrfAppId.value = vrfAppId
	byte 0x7672664170704964 // "vrfAppId"
	frame_dig -2 // vrfAppId: uint64
	app_global_put
	retsub

// depositToFolk(uint64)void
abi_route_depositToFolk:
	byte 0x // push empty bytes to fill the stack frame for this subroutine's local variables

	// value: uint64
	txna ApplicationArgs 1
	btoi

	// execute depositToFolk(uint64)void
	callsub depositToFolk
	int 1
	return

depositToFolk:
	proto 2 0

	// contracts/nftHub.algo.ts:23
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/nftHub.algo.ts:25
	// prevBalance = this.balance.value
	byte 0x62616c616e6365 // "balance"
	app_global_get
	frame_bury -2 // prevBalance: uint64

	// contracts/nftHub.algo.ts:27
	// this.balance.value = prevBalance + value
	byte 0x62616c616e6365 // "balance"
	frame_dig -2 // prevBalance: uint64
	frame_dig -1 // value: uint64
	+
	app_global_put
	retsub

// setClaimedDefault()void
abi_route_setClaimedDefault:
	// execute setClaimedDefault()void
	callsub setClaimedDefault
	int 1
	return

setClaimedDefault:
	proto 0 0

	// contracts/nftHub.algo.ts:31
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/nftHub.algo.ts:32
	// this.claimed.value = [1001, 1001, 1001]
	byte 0x636c61696d6564 // "claimed"
	byte 0x00000000000003e900000000000003e900000000000003e9
	app_global_put
	retsub

// setwinAmount(uint64)void
abi_route_setwinAmount:
	// value: uint64
	txna ApplicationArgs 1
	btoi

	// execute setwinAmount(uint64)void
	callsub setwinAmount
	int 1
	return

setwinAmount:
	proto 1 0

	// contracts/nftHub.algo.ts:36
	// assert(this.txn.sender === this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	assert
	==
	assert

	// contracts/nftHub.algo.ts:37
	// this.winAmount.value = value
	byte 0x77696e416d6f756e74 // "winAmount"
	frame_dig -1 // value: uint64
	app_global_put
	retsub

// checkWinner(uint64,uint64)void
abi_route_checkWinner:
	byte 0x; dupn 6 // push empty bytes to fill the stack frame for this subroutine's local variables

	// value: uint64
	txna ApplicationArgs 2
	btoi

	// tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute checkWinner(uint64,uint64)void
	callsub checkWinner
	int 1
	return

checkWinner:
	proto 9 0

	// contracts/nftHub.algo.ts:41
	// nftAppId = this.nftAppId.value
	byte 0x6e66744170704964 // "nftAppId"
	app_global_get
	frame_bury -3 // nftAppId: uint64

	// contracts/nftHub.algo.ts:42
	// vrfAppId = this.vrfAppId.value
	byte 0x7672664170704964 // "vrfAppId"
	app_global_get
	frame_bury -4 // vrfAppId: uint64

	// contracts/nftHub.algo.ts:43
	// prevBalance = this.balance.value
	byte 0x62616c616e6365 // "balance"
	app_global_get
	frame_bury -5 // prevBalance: uint64

	// contracts/nftHub.algo.ts:45
	// data = sendMethodCall<[uint64], Address>({
	//       name: 'arc72_ownerOf',
	//       applicationID: Application.fromID(nftAppId),
	//       methodArgs: [tokenId],
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "arc72_ownerOf(uint64)address"
	itxn_field ApplicationArgs

	// contracts/nftHub.algo.ts:47
	// applicationID: Application.fromID(nftAppId)
	frame_dig -3 // nftAppId: uint64
	itxn_field ApplicationID

	// contracts/nftHub.algo.ts:48
	// methodArgs: [tokenId]
	frame_dig -1 // tokenId: uint64
	itob
	itxn_field ApplicationArgs

	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury -6 // data: address

	// contracts/nftHub.algo.ts:51
	// dataWinner = sendMethodCall<[], StaticArray<uint64, 3>>({
	//       name: 'getWinners',
	//       applicationID: Application.fromID(vrfAppId),
	//       methodArgs: [],
	//     })
	itxn_begin
	int appl
	itxn_field TypeEnum
	method "getWinners()uint64[3]"
	itxn_field ApplicationArgs

	// contracts/nftHub.algo.ts:53
	// applicationID: Application.fromID(vrfAppId)
	frame_dig -4 // vrfAppId: uint64
	itxn_field ApplicationID

	// contracts/nftHub.algo.ts:54
	// methodArgs: []
	// Fee field not set, defaulting to 0
	int 0
	itxn_field Fee

	// Submit inner transaction
	itxn_submit
	itxn NumLogs
	int 1
	-
	itxnas Logs
	extract 4 0
	frame_bury -7 // dataWinner: uint64[3]

	// if0_condition
	// contracts/nftHub.algo.ts:57
	// this.txn.sender === data
	txn Sender
	frame_dig -6 // data: address
	==
	bz if0_else

	// if0_consequent
	// contracts/nftHub.algo.ts:58
	// indexWinner = 1001
	int 1001
	frame_bury -8 // indexWinner: uint64

	// contracts/nftHub.algo.ts:59
	// i = 0
	int 0
	frame_bury -9 // i: uint64

for_0:
	frame_dig -9 // i: uint64
	int 3
	<
	bz for_0_end

	// if1_condition
	// contracts/nftHub.algo.ts:60
	// tokenId === dataWinner[i]
	frame_dig -1 // tokenId: uint64
	frame_dig -7 // dataWinner: uint64[3]
	store 0 // full array
	int 0 // initial offset
	frame_dig -9 // i: uint64
	int 8
	* // acc * typeLength
	+
	load 0 // full array
	swap
	int 8
	extract3
	btoi
	==
	bz if1_end

	// if1_consequent
	// contracts/nftHub.algo.ts:61
	// indexWinner = i
	frame_dig -9 // i: uint64
	frame_bury -8 // indexWinner: uint64

if1_end:
	// contracts/nftHub.algo.ts:59
	// i = i + 1
	frame_dig -9 // i: uint64
	int 1
	+
	frame_bury -9 // i: uint64
	b for_0

for_0_end:
	// if2_condition
	// contracts/nftHub.algo.ts:64
	// this.claimed.value[indexWinner] === 1001
	byte 0x636c61696d6564 // "claimed"
	app_global_get
	store 0 // full array
	int 0 // initial offset
	frame_dig -8 // indexWinner: uint64
	int 8
	* // acc * typeLength
	+
	load 0 // full array
	swap
	int 8
	extract3
	btoi
	int 1001
	==
	bz if2_else

	// if2_consequent
	// contracts/nftHub.algo.ts:65
	// this.balance.value = prevBalance - value
	byte 0x62616c616e6365 // "balance"
	frame_dig -5 // prevBalance: uint64
	frame_dig -2 // value: uint64
	-
	app_global_put

	// contracts/nftHub.algo.ts:66
	// this.claimed.value[indexWinner] = dataWinner[indexWinner]
	byte 0x636c61696d6564 // "claimed"
	app_global_get
	store 0 // full array
	int 0 // initial offset
	frame_dig -8 // indexWinner: uint64
	int 8
	* // acc * typeLength
	+
	load 0 // full array
	swap
	frame_dig -7 // dataWinner: uint64[3]
	store 0 // full array
	int 0 // initial offset
	frame_dig -8 // indexWinner: uint64
	int 8
	* // acc * typeLength
	+
	load 0 // full array
	swap
	int 8
	extract3
	btoi
	itob
	replace3
	byte 0x636c61696d6564 // "claimed"
	swap
	app_global_put
	b if2_end

if2_else:
	err // 'not a winner'

if2_end:
	b if0_end

if0_else:
	err // 'not nft owner'

if0_end:
	retsub

create_NoOp:
	method "createApplication(uint64,uint64)void"
	txna ApplicationArgs 0
	match abi_route_createApplication
	err

call_NoOp:
	method "depositToFolk(uint64)void"
	method "setClaimedDefault()void"
	method "setwinAmount(uint64)void"
	method "checkWinner(uint64,uint64)void"
	txna ApplicationArgs 0
	match abi_route_depositToFolk abi_route_setClaimedDefault abi_route_setwinAmount abi_route_checkWinner
	err